# 4.5.4 Docker Deployment System
## 4.5.4.1 Docker Compose Deployment

## Figure 4.9: Docker Compose Challenge Deployment Process

The deployFromCompose function initiates the deployment process by logging the start of deployment and optionally updating a progress callback. The function dynamically constructs the path to the challenge's docker-compose.yml file by combining a base repository path (from CLONE_PATH environment variable or default challenges-repo directory) with the specific challengeName. It verifies the file's existence using fs.access to ensure a valid deployment configuration is available, throwing an error if the file is not found. Before deployment, the system proactively prevents network conflicts by disconnecting the ctf-guacd-new container from any previously connected challenge-specific Docker networks. The system inspects the guacd container to retrieve all currently connected networks, then filters for challenge-related networks by excluding the global ctf-instances-network and matching networks against multiple challenge name variants (with hyphens, underscores, case variations, and ctf- prefixes). It iteratively disconnects guacd from each identified challenge-related network using the Docker API with Force: false, with robust error handling that logs failures but continues execution if networks are already disconnected or non-existent, ensuring a clean slate for the new challenge deployment and preventing "network has active endpoints" errors. The system prepares for Docker Compose command execution by dynamically importing Node.js child_process module for shell command execution and util module for promisifying the exec function, creating execPromise to enable asynchronous execution of shell commands. The system executes the docker compose up --build -d command, which builds Docker images from their latest definitions and starts services in detached mode within the specified challengePath directory. If a progress callback is provided, the function uses spawn for real-time streaming of build output, forwarding stdout and stderr data to both the console and the progress callback for live feedback. The system implements intelligent error handling that detects network removal errors (specifically "active endpoints" errors related to guacd connections) and treats them as non-fatal warnings since containers are successfully built and running, allowing deployment to continue. Following successful Docker Compose deployment, the system reads the docker-compose.yml file to extract service configurations and identifies attacker and victim container names by searching for service names containing "attacker" or filtering out attacker and database services. The system inspects actual running containers to retrieve real IP addresses from the challenge network (excluding the global ctf-instances-network), providing more reliable IP detection than parsing docker-compose.yml. If container inspection fails, the system falls back to searching all containers by challenge name pattern or extracting IPs from docker-compose.yml network configurations. The system extracts subnet information from network IPAM configurations and logs deployment completion with subnet, victim IP, and attacker IP details. The function then connects the guacd service to the challenge network by finding the actual Docker network name through container inspection, enabling SSH access to the deployed attacker environment. Finally, the function returns a success object containing the challenge name, container details, IP addresses, and network information, or catches and re-throws any deployment errors with descriptive error messages for debugging purposes.

