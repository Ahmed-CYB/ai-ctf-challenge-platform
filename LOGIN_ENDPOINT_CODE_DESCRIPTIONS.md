# Login Endpoint Code Descriptions

## Figure X1: User Lookup and Account Validation

The login endpoint extracts email and password from the request body, validates both fields are provided, and returns 400 Bad Request if missing. The system queries the PostgreSQL database to locate a user by email address, converting to lowercase for case-insensitive matching. The query retrieves user identification, authentication credentials, profile data, account status, and security fields including account lock status and failed login attempt counters. If no user is found, the endpoint returns 401 Unauthorized with a generic "Invalid email or password" message to prevent user enumeration attacks. Upon successful retrieval, the code performs two security checks: verifying account lock status by comparing `account_locked_until` timestamp with current time (returning 403 Forbidden if locked), and validating account is active via the `is_active` flag to prevent deactivated accounts from authenticating.

## Figure X2: Password Verification and Failed Login Attempt Handling

The authentication process verifies passwords using bcrypt's asynchronous comparison function to securely compare the user-provided password against the stored hash. If verification fails, the system implements a progressive account lockout by incrementing the `failed_login_attempts` counter. A conditional SQL statement automatically locks the account for 15 minutes when failed attempts reach or exceed four, setting `account_locked_until` to current time plus 15 minutes using PostgreSQL interval arithmetic. This protects against brute-force attacks while allowing legitimate users to regain access after the lockout expires. The endpoint returns 401 Unauthorized with the same generic error message used for non-existent users, preventing attackers from distinguishing between invalid emails and incorrect passwords.

## Figure X3: Successful Login Processing and Session Creation

Upon successful password verification, the system resets failed login attempts to zero and updates last login and last active timestamps. The authentication system generates a JWT using the jsonwebtoken library, embedding user ID, username, email, and role into the token payload, signing it with the JWT secret, and setting a seven-day expiration. To prevent session fixation attacks, the system creates a new secure session with a regenerated identifier by extracting the client's IP address and user agent from request headers, passing these attributes along with the user ID to the secure session manager for database storage with expiration and validation. The secure session cookie is set in the HTTP response with HttpOnly, Secure, and SameSite attributes to prevent XSS and CSRF attacks. The system logs the login activity in the user_activity_log table with user ID, activity type, and IP address. Finally, the endpoint returns a JSON response containing success indicator, authentication token, session identifier, and user profile information (user ID, username, email, name, avatar, role) for frontend session establishment.

